# -*- coding: utf-8 -*-
import os
import re
import time

import requests
from aiogram.fsm.context import FSMContext
from aiogram.fsm.state import StatesGroup, State
from aiogram.types import CallbackQuery
from aiogram.types import Message
from groq import Groq
from loguru import logger
from telethon import TelegramClient
from telethon.tl.functions.channels import JoinChannelRequest

from scr.bot.system.dispatcher import api_id, api_hash, USER, PASSWORD, IP, PORT, GROQ_KEY, OAuth, SESSION_NAME
from scr.bot.system.dispatcher import router


def setup_proxy():
    # –£–∫–∞–∑—ã–≤–∞–µ–º –ø—Ä–æ–∫—Å–∏ –¥–ª—è HTTP –∏ HTTPS
    os.environ['http_proxy'] = f"http://{USER}:{PASSWORD}@{IP}:{PORT}"
    os.environ['https_proxy'] = f"http://{USER}:{PASSWORD}@{IP}:{PORT}"


async def get_chat_completion(work: str) -> str:
    """–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –∫–ª—é—á–µ–≤—ã–µ —Å–ª–æ–≤–∞ –∏–∑ —Ç–µ–∫—Å—Ç–∞ –ø–æ—Å—Ç–∞ —á–µ—Ä–µ–∑ –ò–ò"""
    setup_proxy()
    try:
        client = Groq(api_key=GROQ_KEY)
        chat_completion = client.chat.completions.create(
            model="meta-llama/llama-4-maverick-17b-128e-instruct",
            messages=[
                {"role": "system",
                 "content": "–ü—Ä–æ–∞–Ω–∞–ª–∏–∑–∏—Ä—É–π —Ç–µ–∫—Å—Ç –∏ –Ω–∞–π–¥–∏ –∫–ª—é—á–µ–≤—ã–µ —Å–ª–æ–≤–æ—Å–æ—á–µ—Ç–∞–Ω–∏—è. –û–±—Ä–∞—Ç–∏ –≤–Ω–∏–º–∞–Ω–∏–µ, —á—Ç–æ –º–Ω–µ –Ω–µ –Ω—É–∂–Ω–æ –ø–∏—Å–∞—Ç—å "
                            "–º–Ω–æ–≥–æ —Ç–µ–∫—Å—Ç–∞, –º–Ω–µ –Ω—É–∂–µ–Ω –ø—Ä–æ—Å—Ç–æ —Å–ø–∏—Å–æ–∫ —Å–ª–æ–≤–æ—Å–æ—á–µ—Ç–∞–Ω–∏–π –±–µ–∑ 1,2,3 –∏ –±–µ–∑ –ª–∏—à–Ω–µ–≥–æ —Ç–µ–∫—Å—Ç–∞. "
                            "–ù—É–∂–Ω–æ –Ω–µ –±–æ–ª–µ–µ 5 –∫–ª—é—á–µ–≤—ã—Ö —Å–ª–æ–≤–æ—Å–æ—á–µ—Ç–∞–Ω–∏–π"},
                {"role": "user", "content": work},  # <-- –∏—Å–ø–æ–ª—å–∑—É–µ–º —Ç–µ–∫—Å—Ç –ø–æ—Å—Ç–∞
            ],
        )
        return chat_completion.choices[0].message.content
    except Exception as e:
        logger.exception(e)
        return "‚ö†Ô∏è –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞—â–µ–Ω–∏–∏ –∫ –ò–ò"


class AnalysisState(StatesGroup):
    link_post = State()


def ai_text_to_list(text: str) -> list[str]:
    """
    –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ—Ç –º–Ω–æ–≥–æ—Å—Ç—Ä–æ—á–Ω—ã–π —Ç–µ–∫—Å—Ç –≤ —Å–ø–∏—Å–æ–∫ —Å—Ç—Ä–æ–∫.
    –£–±–∏—Ä–∞–µ—Ç –ø—É—Å—Ç—ã–µ —Å—Ç—Ä–æ–∫–∏ –∏ –ø—Ä–æ–±–µ–ª—ã –ø–æ –∫—Ä–∞—è–º.
    """
    return [line.strip() for line in text.splitlines() if line.strip()]


def create_wordstat_report(keyword: str):
    """
    –ü–æ–ª—É—á–µ–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö –ø–æ –∫–ª—é—á–µ–≤–æ–º—É —Å–ª–æ–≤—É –∏–∑ Wordstat API (v1)
    """
    url = "https://api.wordstat.yandex.net/v1/topRequests"
    headers = {
        "Authorization": f"Bearer {OAuth}",
        "Content-Type": "application/json",
    }
    payload = {
        "phrase": keyword,
        "numPhrases": 20,  # –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é 50, –º–∞–∫—Å–∏–º—É–º 2000
        "devices": ["all"],  # –º–æ–∂–Ω–æ: all, desktop, phone, tablet
    }
    response = requests.post(url, json=payload, headers=headers)
    if response.status_code == 200:
        data = response.json()
        logger.debug("üìä –û—Ç–≤–µ—Ç Wordstat:", data)
        return data
    else:
        logger.error(f"‚ùå –û—à–∏–±–∫–∞ Wordstat {response.status_code}: {response.text}")
        return None


def get_wordstat_by_regions(keyword: str, region_type: str = "cities"):
    url = "https://api.wordstat.yandex.net/v1/regions"
    headers = {
        "Authorization": f"Bearer {OAuth}",
        "Content-Type": "application/json",
    }
    payload = {
        "phrase": keyword,
        "regionType": region_type,
        "devices": ["all"],
    }
    response = requests.post(url, json=payload, headers=headers)
    if response.status_code == 200:
        data = response.json()
        logger.debug(f"üìç –†–µ–≥–∏–æ–Ω—ã –ø–æ Wordstat: {data}")
        return data
    else:
        logger.error(f"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ —Ä–µ–≥–∏–æ–Ω–æ–≤ Wordstat {response.status_code}: {response.text}")
        return None


def pretty_wordstat(data: dict) -> str:
    lines = []
    lines.append(f"üìä –ó–∞–ø—Ä–æ—Å: {data['requestPhrase']}")
    lines.append(f"üî¢ –û–±—â–∞—è —á–∞—Å—Ç–æ—Ç–∞: {data['totalCount']:,}".replace(",", " "))
    lines.append("\n‚ú® –¢–æ–ø –∑–∞–ø—Ä–æ—Å—ã:")
    for item in data.get("topRequests", []):
        lines.append(f"   ‚Ä¢ {item['phrase']} ‚Äî {item['count']:,}".replace(",", " "))
    lines.append("\nüîó –ê—Å—Å–æ—Ü–∏–∞—Ü–∏–∏:")
    for item in data.get("associations", []):
        lines.append(f"   ‚Ä¢ {item['phrase']} ‚Äî {item['count']:,}".replace(",", " "))
    return "\n".join(lines)


def pretty_regions(data: dict) -> str:
    result = [f"üìä –†–µ–≥–∏–æ–Ω–∞–ª—å–Ω–∞—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –¥–ª—è –∑–∞–ø—Ä–æ—Å–∞: {data['requestPhrase']}"]
    for region in data.get("regions", []):
        result.append(f"   ‚Ä¢ {region['regionName']} ‚Äî {region['count']:,}")
    return "\n".join(result)


@router.callback_query(lambda c: c.data == "analysis")
async def analysis_callback(callback: CallbackQuery, state: FSMContext):
    """–û—Ç–≤–µ—á–∞–µ—Ç –Ω–∞ –Ω–∞–∂–∞—Ç–∏–µ –∫–Ω–æ–ø–∫–∏ '–ê–Ω–∞–ª–∏–∑'"""

    msg = await callback.message.answer(
        "–ü—Ä–∏—à–ª–∏—Ç–µ —Å—Å—ã–ª–∫—É –Ω–∞ –ø–æ—Å—Ç –≤ Telegram –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞ –ø–æ–∏—Å–∫–æ–≤—ã—Ö –∑–∞–ø—Ä–æ—Å—Å–æ–≤ –ø–æ –∫–ª—é—á–µ–≤—ã–º —Å–ª–æ–≤–∞–º:")
    await state.update_data(prompt_msg_id=msg.message_id)  # —Å–æ—Ö—Ä–∞–Ω–∏–º id —Å–æ–æ–±—â–µ–Ω–∏—è –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è

    # –ü–µ—Ä–µ–≤–æ–¥–∏–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –≤ —Å–æ—Å—Ç–æ—è–Ω–∏–µ –æ–∂–∏–¥–∞–Ω–∏—è —Å—Å—ã–ª–∫–∏
    await state.set_state(AnalysisState.link_post)
    await callback.answer()


# –•–µ–Ω–¥–ª–µ—Ä –ø–æ–ª—É—á–µ–Ω–∏—è —Å—Å—ã–ª–∫–∏ –æ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
@router.message(AnalysisState.link_post)
async def get_link_post_user(message: Message, state: FSMContext):
    """–ü–æ–ª—É—á–∞–µ—Ç —Å—Å—ã–ª–∫—É –æ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è"""

    data = await state.get_data()
    prompt_msg_id = data.get("prompt_msg_id")

    # –£–¥–∞–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ –±–æ—Ç–∞ "–ü—Ä–∏—à–ª–∏—Ç–µ —Å—Å—ã–ª–∫—É..."
    if prompt_msg_id:
        try:
            await message.bot.delete_message(chat_id=message.chat.id, message_id=prompt_msg_id)
        except Exception as e:
            logger.warning(f"–ù–µ —É–¥–∞–ª–æ—Å—å —É–¥–∞–ª–∏—Ç—å —Å–æ–æ–±—â–µ–Ω–∏–µ: {e}")

    link = message.text.strip()
    logger.info(f"–ü–æ–ª—É—á–µ–Ω–∞ —Å—Å—ã–ª–∫–∞: {link}")
    # –°–æ—Ö—Ä–∞–Ω–∏–º —Å—Å—ã–ª–∫—É –≤ FSM (–Ω–∞ –≤—Å—è–∫–∏–π —Å–ª—É—á–∞–π)
    await state.update_data(link_post=link)
    await state.clear()

    await message.answer(
        text=f"‚úÖ –°—Å—ã–ª–∫–∞ –ø–æ–ª—É—á–µ–Ω–∞:\n{link}",
        disable_web_page_preview=True  # –æ—Ç–∫–ª—é—á–∞–µ–º –ø—Ä–µ–≤—å—é –≤ Telegram
    )

    # --- –†–∞–∑–±–∏—Ä–∞–µ–º —Å—Å—ã–ª–∫—É ---
    match_public = re.match(r"https://t\.me/([^/]+)/(\d+)", link)
    match_private = re.match(r"https://t\.me/c/(\d+)/(\d+)", link)
    logger.info(f"match_public: {match_public}, match_private: {match_private}")
    channel, message_id = None, None
    if match_public:
        channel = match_public.group(1)  # username –∫–∞–Ω–∞–ª–∞
        message_id = int(match_public.group(2))  # id –ø–æ—Å—Ç–∞
    elif match_private:
        channel_id = int(match_private.group(1))
        message_id = int(match_private.group(2))
        channel = int(f"-100{channel_id}")  # –ø—Ä–∏–≤–∞—Ç–Ω—ã–µ –∫–∞–Ω–∞–ª—ã –≤ —Ñ–æ—Ä–º–∞—Ç–µ -100XXXXXXXXXX
    else:
        await message.answer("‚ö†Ô∏è –ù–µ–≤–µ—Ä–Ω–∞—è —Å—Å—ã–ª–∫–∞. –ü—Ä–∏—à–ª–∏—Ç–µ —Å—Å—ã–ª–∫—É –Ω–∞ –ø–æ—Å—Ç –≤–∏–¥–∞ https://t.me/username/123")
        return

    # --- –†–∞–±–æ—Ç–∞–µ–º —Å Telethon ---
    async with TelegramClient(f"scr/setting/{SESSION_NAME}", api_id, api_hash) as client:
        await client.connect()
        try:
            # –ï—Å–ª–∏ –∫–∞–Ω–∞–ª –ø—É–±–ª–∏—á–Ω—ã–π ‚Äî –ø–æ–¥–ø–∏—Å—ã–≤–∞–µ–º—Å—è
            if isinstance(channel, str):
                try:
                    await client(JoinChannelRequest(channel))
                except Exception as e:
                    logger.warning(f"–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–¥–ø–∏—Å–∞—Ç—å—Å—è: {e}")
            # –ü–æ–ª—É—á–∞–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ
            msg = await client.get_messages(channel, ids=message_id)
            logger.info(f"–ü–æ–ª—É—á–µ–Ω–æ —Å–æ–æ–±—â–µ–Ω–∏–µ: {msg}")
            post_text = msg.text  # –≤–æ—Ç –∑–¥–µ—Å—å —Ç–µ–∫—Å—Ç –ø–æ—Å—Ç–∞
            logger.info(f"–ü–æ–ª—É—á–µ–Ω —Ç–µ–∫—Å—Ç –ø–æ—Å—Ç–∞: {post_text}")
            if not msg:
                await message.answer("‚ö†Ô∏è –ü–æ—Å—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω.")
                return
            post_text = msg.text or ""  # .message —É—Å—Ç–∞—Ä–µ–ª–æ, –ª—É—á—à–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å .text
            if not post_text.strip():
                await message.answer("‚ö†Ô∏è –ü–æ—Å—Ç –±–µ–∑ —Ç–µ–∫—Å—Ç–∞ (–≤–æ–∑–º–æ–∂–Ω–æ —Ç–æ–ª—å–∫–æ –º–µ–¥–∏–∞).")
                return
            # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –≤ –ò–ò –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞
            ai_answer = await get_chat_completion(work=post_text)
            await message.answer(f"üìå –ö–ª—é—á–µ–≤—ã–µ —Å–ª–æ–≤–∞:\n{ai_answer}")
            keywords = ai_text_to_list(ai_answer)
            logger.debug(keywords)
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –∞–Ω–∞–ª–∏–∑–∞ –ø–æ—Å—Ç–∞: {e}")
            await message.answer("‚ö†Ô∏è –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ –ø–æ—Å—Ç–∞.")

    # --- –†–∞–±–æ—Ç–∞–µ–º —Å Wordstat ---
    for keyword in keywords:
        logger.info(keyword)
        response_json = create_wordstat_report(keyword)

        print(pretty_wordstat(response_json))
        time.sleep(1)

        region = get_wordstat_by_regions(keyword)
        print(pretty_regions(region))
        time.sleep(1)


def register_analysis_handler() -> None:
    router.callback_query.register(analysis_callback)
    router.message.register(get_link_post_user, AnalysisState.link_post)
